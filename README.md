## 更新后的数据集

各类别样本数量
 1(逃花): 143
 2(塞网): 254
 3(破洞): 10
 4(缝头): 319
 5(水渍): 9
 6(脏污): 47
 7(白条): 8
14(未对齐): 562
16(伪色): 7
17(前后色差): 25
20(模板取错): 197
21(漏浆): 7
22(脱浆): 16
23(色纱): 7
24(飞絮): 23

瑕疵块最大边长2048，最小边长51

## 数据读取 data.py

* __load_data(data_path)__

  功能：读取数据集中的所有图片和标注，返回三个数组

  *temp(img1)* 模板图，每一项为50\*50\*3的array 

  *trgt(img2)* 瑕疵图，每一项为50\*50\*3的array 

  *label(info)*  标注，每一项为一个字典，包括瑕疵类别和瑕疵位置，格式为：{"flaw_class":\<int\>, "bbox":[\<int\>,\<int\>,\<int\>,\<int\>]}  

## 数据预处理 process1.py

* __cut(img, bbox)__  

  功能：根据标注边框进行裁剪,返回裁剪后的局部图片。

* __process(img1, img2, bbox)__  

  功能：对一对样本图片进行裁剪，并改变大小。

* __catagory(flaw_type, flaw_count)__

  功能：把样本图片按照瑕疵类别分别存放，对于瑕疵类别 x（取值集合[1, 2, 3, 4, 5, 6, 7, 14, 16, 17, 20, 21, 22, 23, 24]），把该类瑕疵图存进``typex/trgt/``，对应的模板图存进``typex/temp/``。一对样本图片（瑕疵图和模板图）的文件名是一样的，但路径有所不同。

* __aug_collection(flaw_type, flaw_count)__

  功能：把每一类瑕疵图和模板图的数量增加到600。运行完该函数，15个类别总共有18000个图片，瑕疵图和模板图各9000个。

  __Notice：__下面的两个函数还没运行过，file_path需要指定

* __split_data(flaw_type, file_path)__

  功能：把每一类瑕疵的数据集（瑕疵图和模板图）分成训练集和测试集，存储的内容是list，每个元素的格式为：[flaw_type, path]。flaw_type是瑕疵类别，path是文件名。根据瑕疵类别和文件名就能确定一组样本图片。例如，[1, pic1.jpg]表示瑕疵图文件路径``type1/trgt/pic1.jpg``，对应模板图文件路径``type1/temp/pic1.jpg``。

* __conv2numpy(file_path, flaw_type)__

  功能：把split_data划分的训练集和测试集（7：3划分）读取成numpy数组文件

  * x_train1.npy：训练集模板图，(6300,50,50,3)
  * x_test1.npy：测试集模板图，(2700,50,50,3)
  * x_train2.npy：训练集瑕疵图，(6300,50,50,3)
  * x_test2.npy：测试集瑕疵图，(2700,50,50,3)
  * y_train.npy：训练集瑕疵类别，(6300,)
  * y_test.npy：测试集瑕疵类别，(2700,)

## 数据增强 augmentation1.py

对一组样本图片施加同样的变换，主要使用了转置（即图片旋转90度）、左右翻转、上下翻转、改变亮度

## 多层前馈神经网络  

（待编写）  

## 卷积神经网络  

（待编写）  
